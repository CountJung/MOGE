@inherits LayoutComponentBase
@implements IDisposable
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using SharedUI.Logging
@using SharedUI.Services.Settings

@inject AppSettingsService Settings
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject ILogExportService LogExport
@inject MogeLogService LogService

<CascadingValue Value="this" IsFixed="true">
    <MudThemeProvider IsDarkMode="_isDarkMode" />
    <MudPopoverProvider />
    <MudDialogProvider />
    <MudSnackbarProvider />

    <MudBreakpointProvider OnBreakpointChanged="OnBreakpointChanged" />

    <div tabindex="0" style="outline:none;" @onkeydown="OnKeyDownAsync">
    <MudLayout>
        <MudAppBar Dense="true">
            <MudText Typo="Typo.h6">MOGE</MudText>

            <MudSpacer />

            <MudTooltip Text="Settings">
                <MudIconButton Icon="@Icons.Material.Filled.Settings"
                               Color="Color.Inherit"
                               Edge="Edge.End"
                               OnClick="GoSettings"
                               aria-label="Open Settings" />
            </MudTooltip>

            <MudTooltip Text="Download Logs">
                <MudIconButton Icon="@Icons.Material.Filled.Description"
                               Color="Color.Inherit"
                               Edge="Edge.End"
                               OnClick="DownloadLogs"
                               aria-label="Download Logs" />
            </MudTooltip>
        </MudAppBar>

        <MudMainContent>
            <MudContainer MaxWidth="MaxWidth.False" Class="pa-0" Style="padding-bottom: var(--moge-footer-height, 96px);">
                @Body
            </MudContainer>
        </MudMainContent>

        <div @ref="_footerRef" style="position:fixed; left:0; right:0; bottom:0; z-index: 1200;">
            <MudPaper Square="true" Elevation="0" Class="px-3 py-2"
                      Style="border-top:1px solid var(--mud-palette-lines-default);">
                <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                    <MudStack Spacing="0">
                        @foreach (var msg in VisibleFooterMessages)
                        {
                            <MudText Typo="Typo.caption">@msg</MudText>
                        }
                    </MudStack>

                    <MudStack Row="true" Spacing="0" AlignItems="AlignItems.Center">
                        <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowUp" Disabled="@(!CanScrollOlder)" OnClick="ScrollOlder" aria-label="Footer: Older messages" />
                        <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowDown" Disabled="@(!CanScrollNewer)" OnClick="ScrollNewer" aria-label="Footer: Newer messages" />
                    </MudStack>
                </MudStack>
            </MudPaper>
        </div>
    </MudLayout>
    </div>
</CascadingValue>

@code {
    private bool _isMobile;
    private bool _isDarkMode;

    private ElementReference _footerRef;

    public event Func<Task>? UndoRequested;
    public event Func<Task>? RedoRequested;

    private const int FooterMaxMessages = 30;
    private const int FooterPageSize = 3;
    private readonly List<string> _footerMessages = new();
    private int _footerPageOffset;

    protected override async Task OnInitializedAsync()
    {
        await LogService.InitializeAsync();
        await Settings.InitializeAsync();
        await ApplySettingsAsync(Settings.Current);
        Settings.Changed += OnSettingsChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await UpdateFooterHeightCssVarAsync();
    }

    private void OnSettingsChanged(AppSettings s)
    {
        _ = InvokeAsync(() => ApplySettingsAsync(s));
    }

    private async Task ApplySettingsAsync(AppSettings s)
    {
        if (s.ThemeMode == AppThemeMode.Light)
            _isDarkMode = false;
        else if (s.ThemeMode == AppThemeMode.Dark)
            _isDarkMode = true;
        else if (s.ThemeMode == AppThemeMode.System)
            _isDarkMode = await TryGetSystemPrefersDarkAsync(_isDarkMode);

        StateHasChanged();
    }

    private async Task<bool> TryGetSystemPrefersDarkAsync(bool fallback)
    {
        try
        {
            return await JS.InvokeAsync<bool>("mogeTheme.prefersDark");
        }
        catch
        {
            return fallback;
        }
    }

    public void SetFooterMessage(string? message) => PushFooterMessage(message);

    public void PushFooterMessage(string? message)
    {
        if (string.IsNullOrWhiteSpace(message))
            return;

        // Avoid spamming identical consecutive messages.
        if (_footerMessages.Count > 0 && string.Equals(_footerMessages[^1], message, StringComparison.Ordinal))
            return;

        _footerMessages.Add(message);

        if (_footerMessages.Count > FooterMaxMessages)
            _footerMessages.RemoveRange(0, _footerMessages.Count - FooterMaxMessages);

        _footerPageOffset = 0;
        StateHasChanged();
    }

    private async Task UpdateFooterHeightCssVarAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("mogeLayout.setFooterHeightVar", _footerRef);
        }
        catch
        {
            // Best-effort (e.g., during prerender/early startup).
        }
    }

    private IEnumerable<string> VisibleFooterMessages
    {
        get
        {
            if (_footerMessages.Count == 0)
                return Array.Empty<string>();

            var endExclusive = Math.Max(0, _footerMessages.Count - (_footerPageOffset * FooterPageSize));
            var start = Math.Max(0, endExclusive - FooterPageSize);
            if (endExclusive <= start)
                return Array.Empty<string>();

            return _footerMessages.GetRange(start, endExclusive - start);
        }
    }

    private bool CanScrollOlder => _footerMessages.Count - ((_footerPageOffset + 1) * FooterPageSize) > 0;
    private bool CanScrollNewer => _footerPageOffset > 0;

    private void ScrollOlder()
    {
        if (!CanScrollOlder)
            return;

        _footerPageOffset++;
        StateHasChanged();
    }

    private void ScrollNewer()
    {
        if (!CanScrollNewer)
            return;

        _footerPageOffset--;
        StateHasChanged();
    }

    private async Task OnKeyDownAsync(KeyboardEventArgs e)
    {
        try
        {
            if (await JS.InvokeAsync<bool>("mogeLayout.isTextInputFocused"))
                return;
        }
        catch
        {
            // Best-effort. If JS is unavailable, fall back to handling shortcuts.
        }

        if ((e.CtrlKey || e.MetaKey) && string.Equals(e.Key, "z", StringComparison.OrdinalIgnoreCase))
        {
            // Common editor shortcuts: Ctrl+Z = Undo, Ctrl+Shift+Z = Redo
            if (e.ShiftKey)
                _ = RedoRequested?.Invoke();
            else
                _ = UndoRequested?.Invoke();

            return;
        }

        if ((e.CtrlKey || e.MetaKey) && string.Equals(e.Key, "y", StringComparison.OrdinalIgnoreCase))
        {
            // Common Windows shortcut: Ctrl+Y = Redo
            _ = RedoRequested?.Invoke();
            return;
        }

        if (string.Equals(e.Key, "ArrowUp", StringComparison.OrdinalIgnoreCase))
        {
            ScrollOlder();
            return;
        }

        if (string.Equals(e.Key, "ArrowDown", StringComparison.OrdinalIgnoreCase))
        {
            ScrollNewer();
            return;
        }
    }

    private Task OnBreakpointChanged(Breakpoint breakpoint)
    {
        _isMobile = breakpoint < Breakpoint.Md;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void GoSettings() => Nav.NavigateTo("settings");

    private async Task DownloadLogs()
    {
        try
        {
            var result = await LogExport.ExportLatestAsync($"moge-log-{DateOnly.FromDateTime(DateTime.Now):yyyy-MM-dd}.txt");
            PushFooterMessage(result.Message);
        }
        catch
        {
            // Best-effort.
        }
    }

    private static string? ThemeIconStyle(bool isSelected)
    {
        if (!isSelected)
            return null;

        // AppBar 배경색과 상관없이 보이도록 currentColor(=아이콘/텍스트 색) 기반 강조
        return "border:1px solid currentColor; border-radius: var(--mud-default-borderradius);";
    }

    public void Dispose()
    {
        Settings.Changed -= OnSettingsChanged;
    }
}
